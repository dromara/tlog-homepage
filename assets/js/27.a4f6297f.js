(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{485:function(n,t,a){"use strict";a.r(t);var p=a(8),s=Object(p.a)({},(function(){var n=this,t=n._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("p",[n._v("TLog默认的标签打印模板是"),t("code",[n._v("<$spanId><$traceId>")])]),n._v(" "),t("p",[n._v("TLog 中的 SpanId 代表本次调用在整个调用链路树中的位置，假设一个 Web 系统 A 接收了一次用户请求，那么在这个系统的日志中，记录下的 SpanId 是 0，代表是整个调用的根节点，如果 A 系统处理这次请求，需要通过 RPC 依次调用 B，C，D 三个系统，那么在 A 系统的客户端日志中，SpanId 分别是 0.1，0.2 和 0.3，在 B，C，D 三个系统的服务端日志中，SpanId 也分别是 0.1，0.2 和 0.3；如果 C 系统在处理请求的时候又调用了 E，F 两个系统，那么 C 系统中对应的客户端日志是 0.2.1 和 0.2.2，E，F 两个系统对应的服务端日志也是 0.2.1 和 0.2.2。根据上面的描述，我们可以知道，如果把一次调用中所有的 SpanId 收集起来，可以组成一棵完整的链路树。")]),n._v(" "),t("p",[n._v("我们假设一次分布式调用中产生的 TraceId 是 "),t("code",[n._v("0a1234")]),n._v("（实际不会这么短），那么根据上文 SpanId 的产生过程，有下图：")]),n._v(" "),t("p",[t("img",{attrs:{src:"/img/spanid.svg",alt:"3"}})])])}),[],!1,null,null,null);t.default=s.exports}}]);